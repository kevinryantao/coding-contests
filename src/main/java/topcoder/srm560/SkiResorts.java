package topcoder.srm560;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;


public class SkiResorts {

    /*
    Challenges
    ["NYNNNNNN","YNYNNNNN","NYNYNNNN","NNYNYNNN","NNNYNYNN","NNNNYNYN","NNNNNNYN"]
    [0, 0, 0, 1000000, 1000000, 1000000, 1000000, 1000000]


     */

    public long minCost(String[] road, int[] altitude) {
        List<Place> placesList = new ArrayList<Place>();
        for (int anAltitude : altitude) {
            placesList.add(new Place(anAltitude));
        }
        for (int i = 0; i < road.length; i++) {
            for (int j = 0; j < road[i].length(); j++) {
                if (road[i].charAt(j) == 'Y') {
                    placesList.get(i).addNeighbor(placesList.get(j));
                }
            }
        }
        List<List<Place>> listOfPossiblePaths = new ArrayList<List<Place>>();
        Queue<List<Place>> dfsQueue = new LinkedList<List<Place>>();
        List<Place> startingList = new ArrayList<Place>();
        startingList.add(placesList.get(0));

        Place destination = placesList.get(placesList.size() - 1);

        while (!dfsQueue.isEmpty()) {
            List<Place> placesVisitedSoFar = dfsQueue.poll();
            Place currentPlace = placesVisitedSoFar.get(placesVisitedSoFar.size() - 1);
            for (Place nextPlace : currentPlace.neighbors) {
                if (!placesVisitedSoFar.contains(nextPlace)) {
                    List<Place> newList = new ArrayList<Place>();
                    Collections.copy(placesVisitedSoFar, newList);
                    newList.add(nextPlace);
                    if (nextPlace.equals(destination)) {
                        listOfPossiblePaths.add(newList);
                    } else {
                        dfsQueue.offer(newList);
                    }
                }
            }
        }


        return 0;
    }

    public long findCost(List<Place> aPlacesList) {
        long cost = 0;
        int[] altitudes = new int[aPlacesList.size()];
        for(int i = 0; i < aPlacesList.size() - 1; i++){
            altitudes[i] = aPlacesList.get(i).altitude;
        }
        for(int i = 0; i < altitudes.length; i++){

        }


        return 0;
    }

    public class Place {
        int altitude;
        Set<Place> neighbors;

        public Place(int altitude) {
            this.altitude = altitude;
            neighbors = new HashSet<Place>();
        }

        public void addNeighbor(Place aPlace) {
            neighbors.add(aPlace);
        }

        public boolean isConnected(Place aPlace) {
            return neighbors.contains(aPlace);
        }
    }


    // BEGIN KAWIGIEDIT TESTING
    // Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
    private static boolean KawigiEdit_RunTest(int testNum, String[] p0, int[] p1, boolean hasAnswer, long p2) {
        System.out.print("Test " + testNum + ": [" + "{");
        for (int i = 0; p0.length > i; ++i) {
            if (i > 0) {
                System.out.print(",");
            }
            System.out.print("\"" + p0[i] + "\"");
        }
        System.out.print("}" + "," + "{");
        for (int i = 0; p1.length > i; ++i) {
            if (i > 0) {
                System.out.print(",");
            }
            System.out.print(p1[i]);
        }
        System.out.print("}");
        System.out.println("]");
        SkiResorts obj;
        long answer;
        obj = new SkiResorts();
        long startTime = System.currentTimeMillis();
        answer = obj.minCost(p0, p1);
        long endTime = System.currentTimeMillis();
        boolean res;
        res = true;
        System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
        if (hasAnswer) {
            System.out.println("Desired answer:");
            System.out.println("\t" + p2);
        }
        System.out.println("Your answer:");
        System.out.println("\t" + answer);
        if (hasAnswer) {
            res = answer == p2;
        }
        if (!res) {
            System.out.println("DOESN'T MATCH!!!!");
        } else if ((endTime - startTime) / 1000.0 >= 2) {
            System.out.println("FAIL the timeout");
            res = false;
        } else if (hasAnswer) {
            System.out.println("Match :-)");
        } else {
            System.out.println("OK, but is it right?");
        }
        System.out.println("");
        return res;
    }

    public static void main(String[] args) {
        boolean all_right;
        all_right = true;

        String[] p0;
        int[] p1;
        long p2;

        // ----- test 0 -----
        p0 = new String[]{"NYN", "YNY", "NYN"};
        p1 = new int[]{30, 20, 10};
        p2 = 0L;
        all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
        // ------------------

        // ----- test 1 -----
        p0 = new String[]{"NY", "YN"};
        p1 = new int[]{10, 20};
        p2 = 10L;
        all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
        // ------------------

        // ----- test 2 -----
        p0 = new String[]{"NYN", "YNN", "NNN"};
        p1 = new int[]{573, 573, 573};
        p2 = -1L;
        all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
        // ------------------

        // ----- test 3 -----
        p0 = new String[]{"NNYNNYYYNN", "NNNNYNYNNN", "YNNNNYYNNN", "NNNNNNYNYY", "NYNNNNNNYY", "YNYNNNNYNN", "YYYYNNNYNN", "YNNNNYYNNN", "NNNYYNNNNN", "NNNYYNNNNN"};
        p1 = new int[]{7, 4, 13, 2, 8, 1, 8, 15, 5, 15};
        p2 = 12L;
        all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
        // ------------------

        if (all_right) {
            System.out.println("You're a stud (at least on the example cases)!");
        } else {
            System.out.println("Some of the test cases had errors.");
        }
    }
    // END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!